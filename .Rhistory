# Get Kingdom/Domain column
kingdoms <- tax_table[, "Kingdom"]
# Dataset 1: Bacteria only
bacteria_idx <- grepl("Bacteria", kingdoms, ignore.case = TRUE)
feature_table_bacteria <- feature_table[bacteria_idx, ]
tax_table_bacteria <- tax_table[bacteria_idx, ]
# Dataset 2: Bacteria and Archaea
bacteria_archaea_idx <- grepl("Bacteria|Archaea", kingdoms, ignore.case = TRUE)
feature_table_bacteria_archaea <- feature_table[bacteria_archaea_idx, ]
tax_table_bacteria_archaea <- tax_table[bacteria_archaea_idx, ]
cat("Dataset summary:\n")
cat("  Total features:", nrow(feature_table), "\n")
cat("  Bacteria only:", nrow(feature_table_bacteria), "\n")
cat("  Bacteria + Archaea:", nrow(feature_table_bacteria_archaea), "\n\n")
# Create output directories for each dataset
dir.create("Results/denoise_mode/bacteria_only", showWarnings = FALSE, recursive = TRUE)
dir.create("Results/denoise_mode/bacteria_archaea", showWarnings = FALSE, recursive = TRUE)
# Function to run analysis on a dataset
run_analysis <- function(ft, tt, meta, output_prefix, dataset_name) {
cat("\n=== Processing", dataset_name, "===\n")
# Relative abundance
rel_abundance <- sweep(ft, 2, colSums(ft), "/") * 100
# Aggregate by genus
aggregate_by_level <- function(feat_table, tax_table, level) {
# Ensure feature tables and taxonomy tables are aligned
common_features <- intersect(rownames(feat_table), rownames(tax_table))
feat_table <- feat_table[common_features, , drop = FALSE]
tax_table <- tax_table[common_features, , drop = FALSE]
taxa <- tax_table[, level]
taxa[is.na(taxa)] <- "Unclassified"
agg_table <- aggregate(feat_table, by = list(Taxa = taxa), FUN = sum)
rownames(agg_table) <- agg_table$Taxa
agg_table$Taxa <- NULL
return(as.data.frame(agg_table))
}
genus_abund <- aggregate_by_level(rel_abundance, tt, "Genus")
# Heatmap
plot_heatmap <- function(abund_table, metadata, top_n = 30, cluster_samples = TRUE, group_var = "sample_type") {
mean_abund <- rowMeans(abund_table)
top_taxa <- names(sort(mean_abund, decreasing = TRUE)[1:top_n])
heat_data <- abund_table[top_taxa, ]
heat_data_log <- log10(heat_data + 0.01)
annotation_col <- metadata[, group_var, drop = FALSE]
# Custom colors for sample_type annotation
sample_types <- unique(metadata[, group_var])
annotation_colors <- list()
if (length(sample_types) == 3) {
annotation_colors[[group_var]] <- c("green3", "purple3", "gold")
names(annotation_colors[[group_var]]) <- sort(sample_types)
}
pheatmap::pheatmap(
heat_data_log,
cluster_rows = TRUE,
cluster_cols = cluster_samples,
annotation_col = annotation_col,
annotation_colors = annotation_colors,
color = colorRampPalette(c("navy", "white", "firebrick3"))(50),
fontsize = 8,
fontsize_row = 7,
fontsize_col = 8,
main = paste("Top", top_n, "Taxa Heatmap -", dataset_name, "\n[log10(Relative Abundance %)]"),
filename = paste0(output_prefix, "_taxa_heatmap.pdf"),
width = 10,
height = 12
)
}
plot_heatmap(genus_abund, meta, top_n = 30, group_var = "sample_type")
cat("Heatmap saved\n")
# Alpha diversity
alpha_div <- data.frame(
Sample = colnames(ft),
ASV_abundance = colSums(ft > 0),
Shannon = vegan::diversity(t(ft), index = "shannon"),
Simpson = vegan::diversity(t(ft), index = "simpson")
)
alpha_div <- cbind(alpha_div, meta[alpha_div$Sample, ])
alpha_long <- alpha_div %>%
pivot_longer(cols = c(ASV_abundance, Shannon, Simpson), names_to = "Metric", values_to = "Value")
p_alpha <- ggplot(alpha_long, aes(x = sample_type, y = Value, fill = sample_type)) +
geom_boxplot() +
facet_wrap(~ Metric, scales = "free_y") +
theme_bw() +
labs(title = paste("Alpha Diversity -", dataset_name), x = "Sample Type", y = "Value") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p_alpha)
ggsave(paste0(output_prefix, "_alpha_diversity_boxplot.pdf"), p_alpha, width = 10, height = 4)
cat("Alpha diversity boxplot saved\n")
# PCoA ordination using Unweighted UniFrac from QIIME2
cat("\n=== PCoA with Unweighted UniFrac ===\n")
unweighted_pcoa_file <- "Results/denoise_mode/diversity/exported-unweighted_unifrac-pcoa/ordination.txt"
unweighted_dist_file <- "Results/denoise_mode/diversity/unweighted_unifrac_exported/distance-matrix.tsv"
# Parse QIIME2 ordination file (robust parsing)
lines <- readLines(unweighted_pcoa_file)
prop_idx_all <- grep("^Proportion", lines)
site_idx_all <- grep("^Site", lines)
if (length(prop_idx_all) < 1 || length(site_idx_all) < 1) {
stop("Could not find Proportion or Site sections in ordination file: ", unweighted_pcoa_file)
}
prop_idx <- prop_idx_all[1]
site_idx <- site_idx_all[1]
# Proportion line(s) may be on a single line; take the next non-empty line after prop_idx
prop_line_idx <- prop_idx + 1
while(prop_line_idx <= length(lines) && nchar(trimws(lines[prop_line_idx])) == 0) prop_line_idx <- prop_line_idx + 1
prop_line <- lines[prop_line_idx]
prop_tokens <- unlist(strsplit(prop_line, "[\t ]+"))
prop_tokens <- prop_tokens[prop_tokens != ""]
percent_var <- round(as.numeric(prop_tokens) * 100, 2)
# Coordinates: read lines after Site until the next blank line (or end)
coord_start <- site_idx + 1
# find first blank line after coord_start
blank_after <- which(nchar(trimws(lines)) == 0)
blank_after <- blank_after[blank_after > site_idx]
coord_end <- if (length(blank_after) > 0) (blank_after[1] - 1) else length(lines)
coord_lines <- lines[coord_start:coord_end]
coord_lines <- coord_lines[nzchar(trimws(coord_lines))]
# Parse coordinate block using read.table for consistent columns
coord_tab <- read.table(text = paste(coord_lines, collapse = "\n"), sep = "\t", header = FALSE, stringsAsFactors = FALSE, fill = TRUE)
if (ncol(coord_tab) < 3) stop("PCoA coord table has fewer than 3 columns")
pcoa_scores <- data.frame(
Sample = coord_tab[, 1],
PC1 = as.numeric(coord_tab[, 2]),
PC2 = as.numeric(coord_tab[, 3]),
stringsAsFactors = FALSE
)
rownames(pcoa_scores) <- pcoa_scores$Sample
# Merge PCoA scores with metadata. Use full metadata so we can show ordination samples
# even if they are not part of the current feature table subset.
meta_for_merge <- if (exists("metadata_full")) metadata_full else meta
meta_for_merge_df <- data.frame(Sample = rownames(meta_for_merge), meta_for_merge, stringsAsFactors = FALSE)
pcoa_scores <- merge(pcoa_scores, meta_for_merge_df, by = "Sample", all.x = TRUE)
# Report samples missing metadata (if any)
missing_meta <- pcoa_scores$Sample[is.na(pcoa_scores$sample_type) & is.na(pcoa_scores$species)]
if (length(missing_meta) > 0) {
cat("Warning: the following PCoA samples have no matching metadata rows (they will be plotted with NA categories):\n")
cat(paste(missing_meta, collapse = ", "), "\n")
}
# For plotting, ensure sample_type and species exist and handle NA values
if (!("sample_type" %in% colnames(pcoa_scores))) pcoa_scores$sample_type <- NA
if (!("species" %in% colnames(pcoa_scores))) pcoa_scores$species <- NA
pcoa_scores$sample_type <- as.character(pcoa_scores$sample_type)
pcoa_scores$sample_type[is.na(pcoa_scores$sample_type)] <- "Unknown"
pcoa_scores$sample_type <- factor(pcoa_scores$sample_type)
# Read distance matrix for PERMANOVA
unifrac_dist_data <- read.table(unweighted_dist_file, sep = "\t", header = TRUE, row.names = 1)
# Ensure we subset the distance matrix to samples present in the ordination
dist_samples_all <- rownames(unifrac_dist_data)
common_samples <- intersect(dist_samples_all, pcoa_scores$Sample)
if (length(common_samples) == 0) stop("No matching samples between distance matrix and ordination scores")
unifrac_dist_data <- unifrac_dist_data[common_samples, common_samples, drop = FALSE]
pcoa_dist <- as.dist(unifrac_dist_data)
cat("Using QIIME2 Unweighted UniFrac results\n")
# Plot PCoA
cat("\n=== Plotting PCoA ===\n")
p_pcoa <- ggplot(pcoa_scores, aes(x = PC1, y = PC2, color = sample_type, shape = species)) +
geom_point(size = 4, alpha = 0.8) +
theme_bw() +
labs(
title = paste("PCoA - Unweighted UniFrac -", dataset_name),
x = paste0("PC1 (", percent_var[1], "%)"),
y = paste0("PC2 (", percent_var[2], "%)"),
color = "Sample Type",
shape = "Species"
) +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
)
print(p_pcoa)
ggsave(paste0(output_prefix, "_pcoa_unweighted_unifrac.pdf"), p_pcoa, width = 10, height = 7)
cat("PCoA plot saved to:", paste0(output_prefix, "_pcoa_unweighted_unifrac.pdf\n"))
# PERMANOVA analysis
cat("\n=== PERMANOVA Analysis ===\n")
# Ensure metadata matches distance matrix samples
dist_samples <- labels(pcoa_dist)
# Use the full metadata copy (metadata_full) when matching against distance matrix / ordination
meta_for_perm <- if (exists("metadata_full")) metadata_full else meta
meta_subset <- meta_for_perm[dist_samples, , drop = FALSE]
# Run tests
if (length(unique(meta_subset$species)) > 1) {
permanova_species <- adonis2(pcoa_dist ~ species, data = meta_subset, permutations = 999)
cat("\n1. Tree Species Effect:\n")
print(permanova_species)
}
if (length(unique(meta_subset$sample_type)) > 1) {
permanova_tissue <- adonis2(pcoa_dist ~ sample_type, data = meta_subset, permutations = 999)
cat("\n2. Tissue Effect:\n")
print(permanova_tissue)
}
if (length(unique(meta_subset$species)) > 1 && length(unique(meta_subset$sample_type)) > 1) {
permanova_combined <- adonis2(pcoa_dist ~ species + sample_type, data = meta_subset, permutations = 999)
cat("\n3. Combined Effect:\n")
print(permanova_combined)
permanova_interaction <- adonis2(pcoa_dist ~ species * sample_type, data = meta_subset, permutations = 999)
cat("\n4. Interaction Effect:\n")
print(permanova_interaction)
}
# Save results
sink(paste0(output_prefix, "_PERMANOVA_results.txt"))
cat("PERMANOVA Test Results -", dataset_name, "\n")
cat("Date:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n")
cat("Distance metric: Unweighted UniFrac\n")
cat("Permutations: 999\n\n")
cat(paste(rep("=", 70), collapse = ""), "\n\n")
if (length(unique(meta$species)) > 1) {
cat("1. Tree Species Effect (dm ~ tree_species):\n")
print(permanova_species)
cat("\n")
}
if (length(unique(meta$sample_type)) > 1) {
cat("2. Tissue Effect (dm ~ tissue):\n")
print(permanova_tissue)
cat("\n")
}
if (length(unique(meta$species)) > 1 && length(unique(meta$sample_type)) > 1) {
cat("3. Combined Effect (dm ~ tree_species + tissue):\n")
print(permanova_combined)
cat("\n")
cat("4. Interaction Effect (dm ~ tree_species * tissue):\n")
print(permanova_interaction)
cat("\n")
}
cat(paste(rep("=", 70), collapse = ""), "\n")
cat("\nInterpretation:\n")
cat("- Pr(>F) < 0.001: *** (highly significant)\n")
cat("- Pr(>F) < 0.01:  **  (significant)\n")
cat("- Pr(>F) < 0.05:  *   (marginally significant)\n")
cat("- Pr(>F) >= 0.05: not significant\n\n")
cat("PERMANOVA tests whether community composition differs significantly between groups.\n")
cat("RÂ² represents the proportion of variance explained by each factor.\n")
sink()
cat("PERMANOVA results saved to file\n")
cat("\n", dataset_name, "analysis complete\n")
}
# Run analysis for both datasets
run_analysis(feature_table_bacteria, tax_table_bacteria, metadata,
"Results/denoise_mode/bacteria_only/bacteria_only", "Bacteria Only")
View(metadata_full)
View(metadata_full)
# Import data
feature_table <- read.table(
"Results/denoise_mode/exported-table/feature-table.tsv",
header = TRUE,
sep = "\t",
skip = 1,
row.names = 1,
comment.char = ""
)
View(feature_table)
# Load required packages
required_packages <- c("tidyverse", "vegan", "ggplot2", "RColorBrewer", "pheatmap")
for (pkg in required_packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
library(pkg, character.only = TRUE)
}
}
setwd("/Users/jiayi/Desktop/metagenomic_pipeline/QIIME")
# Import data
feature_table <- read.table(
"Results/denoise_mode/exported-table/feature-table.tsv",
header = TRUE,
sep = "\t",
skip = 1,
row.names = 1,
comment.char = ""
)
feature_table <- feature_table[, !(colnames(feature_table) %in% c("A1", "A2")), drop = FALSE]
taxonomy <- read.table(
"Results/denoise_mode/exported-taxonomy/taxonomy.tsv",
header = TRUE,
sep = "\t",
row.names = 1,
quote = ""
)
metadata <- read.table(
"Data/metadata/metadata.tsv",
header = TRUE,
sep = "\t",
row.names = 1,
comment.char = ""
)
# Parse taxonomy
parse_taxonomy <- function(tax_string) {
tax_clean <- gsub("\\s*\\([^\\)]+\\)", "", tax_string)
levels <- strsplit(tax_clean, ";")[[1]]
levels <- trimws(levels)
tax_levels <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")
result <- rep(NA, 7)
names(result) <- tax_levels
result[1:min(length(levels), 7)] <- levels[1:min(length(levels), 7)]
return(result)
}
tax_table <- t(sapply(taxonomy$Taxon, parse_taxonomy))
rownames(tax_table) <- rownames(taxonomy)
# Remove Cyanobacteria and Chloroplast
cat("Filtering out Cyanobacteria and Chloroplast...\n")
cat("  Features before filtering:", nrow(feature_table), "\n")
# Identify sequences to remove
remove_idx <- (
grepl("Cyanobacteria", tax_table[, "Phylum"], ignore.case = TRUE) |
grepl("Cyanobacteriia", tax_table[, "Class"], ignore.case = TRUE) |
grepl("Chloroplast", tax_table[, "Order"], ignore.case = TRUE) |
grepl("Chloroplast", tax_table[, "Family"], ignore.case = TRUE) |
grepl("Chloroplast", tax_table[, "Genus"], ignore.case = TRUE)
)
cat("  Cyanobacteria/Chloroplast features found:", sum(remove_idx), "\n")
# Remove from both feature table and taxonomy table
feature_table <- feature_table[!remove_idx, ]
tax_table <- tax_table[!remove_idx, ]
cat("  Features after filtering:", nrow(feature_table), "\n\n")
# Filter datasets by domain
cat("Filtering datasets by domain...\n")
# Get Kingdom/Domain column
kingdoms <- tax_table[, "Kingdom"]
# Dataset 1: Bacteria only
bacteria_idx <- grepl("Bacteria", kingdoms, ignore.case = TRUE)
feature_table_bacteria <- feature_table[bacteria_idx, ]
tax_table_bacteria <- tax_table[bacteria_idx, ]
# Dataset 2: Bacteria and Archaea
bacteria_archaea_idx <- grepl("Bacteria|Archaea", kingdoms, ignore.case = TRUE)
feature_table_bacteria_archaea <- feature_table[bacteria_archaea_idx, ]
tax_table_bacteria_archaea <- tax_table[bacteria_archaea_idx, ]
cat("Dataset summary:\n")
cat("  Total features:", nrow(feature_table), "\n")
cat("  Bacteria only:", nrow(feature_table_bacteria), "\n")
cat("  Bacteria + Archaea:", nrow(feature_table_bacteria_archaea), "\n\n")
# Create output directories for each dataset
dir.create("Results/denoise_mode/bacteria_only", showWarnings = FALSE, recursive = TRUE)
dir.create("Results/denoise_mode/bacteria_archaea", showWarnings = FALSE, recursive = TRUE)
# Function to run analysis on a dataset
run_analysis <- function(ft, tt, meta, output_prefix, dataset_name) {
cat("\n=== Processing", dataset_name, "===\n")
# Relative abundance
rel_abundance <- sweep(ft, 2, colSums(ft), "/") * 100
# Aggregate by genus
aggregate_by_level <- function(feat_table, tax_table, level) {
# Ensure feature tables and taxonomy tables are aligned
common_features <- intersect(rownames(feat_table), rownames(tax_table))
feat_table <- feat_table[common_features, , drop = FALSE]
tax_table <- tax_table[common_features, , drop = FALSE]
taxa <- tax_table[, level]
taxa[is.na(taxa)] <- "Unclassified"
agg_table <- aggregate(feat_table, by = list(Taxa = taxa), FUN = sum)
rownames(agg_table) <- agg_table$Taxa
agg_table$Taxa <- NULL
return(as.data.frame(agg_table))
}
genus_abund <- aggregate_by_level(rel_abundance, tt, "Genus")
# Heatmap
plot_heatmap <- function(abund_table, metadata, top_n = 30, cluster_samples = TRUE, group_var = "sample_type") {
mean_abund <- rowMeans(abund_table)
top_taxa <- names(sort(mean_abund, decreasing = TRUE)[1:top_n])
heat_data <- abund_table[top_taxa, ]
heat_data_log <- log10(heat_data + 0.01)
annotation_col <- metadata[, group_var, drop = FALSE]
# Custom colors for sample_type annotation
sample_types <- unique(metadata[, group_var])
annotation_colors <- list()
if (length(sample_types) == 3) {
annotation_colors[[group_var]] <- c("green3", "purple3", "gold")
names(annotation_colors[[group_var]]) <- sort(sample_types)
}
pheatmap::pheatmap(
heat_data_log,
cluster_rows = TRUE,
cluster_cols = cluster_samples,
annotation_col = annotation_col,
annotation_colors = annotation_colors,
color = colorRampPalette(c("navy", "white", "firebrick3"))(50),
fontsize = 8,
fontsize_row = 7,
fontsize_col = 8,
main = paste("Top", top_n, "Taxa Heatmap -", dataset_name, "\n[log10(Relative Abundance %)]"),
filename = paste0(output_prefix, "_taxa_heatmap.pdf"),
width = 10,
height = 12
)
}
plot_heatmap(genus_abund, meta, top_n = 30, group_var = "sample_type")
cat("Heatmap saved\n")
# Alpha diversity
alpha_div <- data.frame(
Sample = colnames(ft),
ASV_abundance = colSums(ft > 0),
Shannon = vegan::diversity(t(ft), index = "shannon"),
Simpson = vegan::diversity(t(ft), index = "simpson")
)
alpha_div <- cbind(alpha_div, meta[alpha_div$Sample, ])
alpha_long <- alpha_div %>%
pivot_longer(cols = c(ASV_abundance, Shannon, Simpson), names_to = "Metric", values_to = "Value")
p_alpha <- ggplot(alpha_long, aes(x = sample_type, y = Value, fill = sample_type)) +
geom_boxplot() +
facet_wrap(~ Metric, scales = "free_y") +
theme_bw() +
labs(title = paste("Alpha Diversity -", dataset_name), x = "Sample Type", y = "Value") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p_alpha)
ggsave(paste0(output_prefix, "_alpha_diversity_boxplot.pdf"), p_alpha, width = 10, height = 4)
cat("Alpha diversity boxplot saved\n")
# --- PCoA and PERMANOVA (Global Unweighted UniFrac) ---
# Note: This uses the global ordination/distance matrix, not specific to the subset (Bacteria/Archaea)
# unless those files are updated. We run this block to visualize the provided QIIME2 results.
cat("\n=== PCoA with Unweighted UniFrac (QIIME2) ===\n")
unweighted_pcoa_file <- "Results/denoise_mode/diversity/exported-unweighted_unifrac-pcoa/ordination.txt"
unweighted_dist_file <- "Results/denoise_mode/diversity/unweighted_unifrac_exported/distance-matrix.tsv"
if (file.exists(unweighted_pcoa_file)) {
# Robust Parsing of QIIME2 ordination file
lines <- readLines(unweighted_pcoa_file)
prop_idx_all <- grep("^Proportion", lines)
site_idx_all <- grep("^Site", lines)
if (length(prop_idx_all) > 0 && length(site_idx_all) > 0) {
prop_idx <- prop_idx_all[1]
site_idx <- site_idx_all[1]
# Parse Proportion Explained
prop_line_idx <- prop_idx + 1
while(prop_line_idx <= length(lines) && nchar(trimws(lines[prop_line_idx])) == 0) prop_line_idx <- prop_line_idx + 1
prop_tokens <- unlist(strsplit(lines[prop_line_idx], "[\t ]+"))
prop_tokens <- prop_tokens[prop_tokens != ""]
percent_var <- round(as.numeric(prop_tokens) * 100, 2)
# Parse Site Coordinates
coord_start <- site_idx + 1
# Find end of coordinate block (first blank line after start)
blank_lines <- which(nchar(trimws(lines)) == 0)
coord_end <- if (any(blank_lines > coord_start)) min(blank_lines[blank_lines > coord_start]) - 1 else length(lines)
coord_lines <- lines[coord_start:coord_end]
coord_lines <- coord_lines[nzchar(trimws(coord_lines))]
if (length(coord_lines) > 0) {
coord_tab <- read.table(text = paste(coord_lines, collapse = "\n"), header = FALSE, stringsAsFactors = FALSE, fill = TRUE)
# Expecting SampleID, PC1, PC2, ...
pcoa_scores <- data.frame(
Sample = coord_tab[, 1],
PC1 = as.numeric(coord_tab[, 2]),
PC2 = as.numeric(coord_tab[, 3]),
stringsAsFactors = FALSE
)
# Merge with Metadata (Left Join to keep all ordination samples)
# We use the full 'metadata' object (which is now not subsetted)
meta_df <- data.frame(Sample = rownames(metadata), metadata, stringsAsFactors = FALSE)
plot_data <- merge(pcoa_scores, meta_df, by = "Sample", all.x = TRUE)
# Handle missing metadata for plotting
if (!"sample_type" %in% colnames(plot_data)) plot_data$sample_type <- NA
if (!"species" %in% colnames(plot_data)) plot_data$species <- NA
plot_data$sample_type[is.na(plot_data$sample_type)] <- "Unknown"
plot_data$species[is.na(plot_data$species)] <- "Unknown"
# Plot PCoA
p_pcoa <- ggplot(plot_data, aes(x = PC1, y = PC2, color = sample_type, shape = species)) +
geom_point(size = 4, alpha = 0.8) +
theme_bw() +
labs(
title = paste("PCoA - Unweighted UniFrac (QIIME2)"),
subtitle = paste("Dataset context:", dataset_name),
x = paste0("PC1 (", percent_var[1], "%)"),
y = paste0("PC2 (", percent_var[2], "%)"),
color = "Sample Type",
shape = "Species"
) +
theme(plot.title = element_text(hjust = 0.5))
ggsave(paste0(output_prefix, "_pcoa_unweighted_unifrac.pdf"), p_pcoa, width = 10, height = 7)
cat("PCoA plot saved to:", paste0(output_prefix, "_pcoa_unweighted_unifrac.pdf\n"))
# Save Scores
write.table(plot_data, paste0(output_prefix, "_pcoa_scores.tsv"), sep = "\t", quote = FALSE, row.names = FALSE)
}
}
} else {
cat("Ordination file not found:", unweighted_pcoa_file, "\n")
}
# --- PERMANOVA ---
cat("\n=== PERMANOVA Analysis ===\n")
if (file.exists(unweighted_dist_file)) {
dist_mat <- read.table(unweighted_dist_file, header = TRUE, sep = "\t", row.names = 1, check.names = FALSE)
# Intersect samples between distance matrix and metadata
# We need valid metadata for PERMANOVA factors
common_samples <- intersect(rownames(dist_mat), rownames(metadata))
# Filter out samples with NA in key columns if necessary, or just use common ones
# Here we just use samples present in both.
if (length(common_samples) > 0) {
dist_subset <- as.dist(dist_mat[common_samples, common_samples])
meta_subset <- metadata[common_samples, , drop = FALSE]
sink(paste0(output_prefix, "_PERMANOVA_results.txt"))
cat("PERMANOVA Results (Unweighted UniFrac)\n")
cat("Samples used:", length(common_samples), "\n\n")
# Test Species
if ("species" %in% colnames(meta_subset) && length(unique(meta_subset$species)) > 1) {
cat("--- Effect of Species ---\n")
tryCatch({
print(adonis2(dist_subset ~ species, data = meta_subset, permutations = 999))
}, error = function(e) cat("Error running PERMANOVA on species:", e$message, "\n"))
cat("\n")
}
# Test Sample Type
if ("sample_type" %in% colnames(meta_subset) && length(unique(meta_subset$sample_type)) > 1) {
cat("--- Effect of Sample Type ---\n")
tryCatch({
print(adonis2(dist_subset ~ sample_type, data = meta_subset, permutations = 999))
}, error = function(e) cat("Error running PERMANOVA on sample_type:", e$message, "\n"))
cat("\n")
}
sink()
cat("PERMANOVA results saved to:", paste0(output_prefix, "_PERMANOVA_results.txt\n"))
} else {
cat("No common samples between distance matrix and metadata for PERMANOVA.\n")
}
} else {
cat("Distance matrix file not found:", unweighted_dist_file, "\n")
}
cat("\n", dataset_name, "analysis complete\n")
}
# Run analysis for both datasets
run_analysis(feature_table_bacteria, tax_table_bacteria, metadata,
"Results/denoise_mode/bacteria_only/bacteria_only", "Bacteria Only")
run_analysis(feature_table_bacteria_archaea, tax_table_bacteria_archaea, metadata,
"Results/denoise_mode/bacteria_archaea/bacteria_archaea", "Bacteria + Archaea")
